
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Chatbot</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f4f4f9;
    }
    #chat-window {
      width: 80%;
      max-width: 600px;
      height: 400px;
      border: 1px solid #ccc;
      border-radius: 10px;
      overflow-y: auto;
      background-color: #fff;
      padding: 10px;
      margin-top: 20px;
    }
    #user-input {
      width: 80%;
      max-width: 600px;
      padding: 10px;
      margin-top: 10px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }
    #send-btn, #refresh-btn, #export-btn {
      margin-top: 10px;
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #send-btn:hover, #refresh-btn:hover, #export-btn:hover {
      background-color: #45a049;
    }
    #training-export {
      margin-top: 20px;
      padding: 10px;
      background-color: #f9f9f9;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 80%;
      max-width: 600px;
      word-wrap: break-word;
    }
    #training-export textarea {
      width: 100%;
      height: 200px;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 10px;
      background-color: #fff;
      font-family: monospace;
      font-size: 14px;
      resize: none;
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <h1>AI Chatbot</h1>
  <div id="chat-window"></div>
  <input type="text" id="user-input" placeholder="Type your message..."/>
  <button id="send-btn">Send</button>
  <button id="refresh-btn">Refresh Model</button>
  <button id="export-btn">Export Conversations</button>
  <div id="training-export">
    <textarea readonly id="export-text"></textarea>
  </div>

  <script>
    const dataUrl = 'https://raw.githubusercontent.com/KingJ23341/AIbot/refs/heads/main/trainingdata.json';
    let trainingData = null;
    let conversationHistory = [];

    async function loadTrainingData() {
      const startTime = performance.now();
      try {
        const response = await fetch(dataUrl);
        const data = await response.json();
        const endTime = performance.now();

        const fetchTime = (endTime - startTime).toFixed(2);
        const sizeInBytes = new TextEncoder().encode(JSON.stringify(data)).length;
        const sizeInKB = (sizeInBytes / 1024).toFixed(2);
        const sizeInMB = (sizeInKB / 1024).toFixed(2);

        trainingData = data;
        appendMessage('System', `Training data loaded in ${fetchTime} ms.`);
        appendMessage('System', `Data size: ${sizeInBytes} bytes (${sizeInKB} KB, ${sizeInMB} MB)`);

      } catch (error) {
        console.error('Error loading training data:', error);
        appendMessage('System', 'Failed to load training data.');
      }
    }

    function tokenize(text) {
      return text.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
    }

    function getResponse(userInput) {
      if (!trainingData) {
        return "I'm still loading. Please wait!";
      }

      const inputTokens = tokenize(userInput);
      let bestMatch = null;
      let maxOverlap = 0;

      // Use conversation samples
      trainingData.conversationsamples.forEach((sample) => {
        const botTokens = tokenize(sample.user);
        const overlap = botTokens.filter((token) => inputTokens.includes(token)).length;

        if (overlap > maxOverlap) {
          maxOverlap = overlap;
          bestMatch = sample.bot;
        }
      });

      // Use training data if no match found
      if (!bestMatch) {
        trainingData.traineddata.forEach((data) => {
          const overlap = data.toLowerCase().split(' ').filter((word) => inputTokens.includes(word)).length;
          if (overlap > maxOverlap) {
            maxOverlap = overlap;
            bestMatch = data;
          }
        });
      }

      return bestMatch || "I don't understand that. Can you rephrase?";
    }

    function appendMessage(sender, message) {
      const chatWindow = document.getElementById('chat-window');
      const p = document.createElement('p');
      p.innerHTML = `<strong>${sender}:</strong> ${message}`;
      chatWindow.appendChild(p);
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }


    function refreshTrainingData() {
      appendMessage('System', 'Refreshing training data...');
      loadTrainingData();
    }

    function updateTrainingExport() {
      const exportContainer = document.getElementById('export-text');
      const newConversationSamples = trainingData.conversationsamples.map(sample => 
        `{
  "user": "${sample.user}",
  "bot": "${sample.bot}"
}`).join('\n\n');

      exportContainer.textContent = newConversationSamples;
    }

async function handleMessage() {
  const userInput = document.getElementById('user-input').value.trim();
  if (!userInput) return;

  appendMessage('You', userInput);
  appendMessage('Bot', '...typing...');

  // Simulate response delay
  setTimeout(() => {
    const chatWindow = document.getElementById('chat-window');
    const inquiries = userInput.split(/,?\s+and\s+/); // Split input by "and" to handle multiple inquiries
    let response = '';

    inquiries.forEach((inquiry, index) => {
      response += getResponse(inquiry) + (index < inquiries.length - 1 ? ' ' : '');
    });

    // Update the last message in the chat window after response generation
    chatWindow.lastChild.innerHTML = `<strong>Bot:</strong> ${response}`;
    document.getElementById('user-input').value = '';

    // Push both user input and bot response into the conversation history
    conversationHistory.push({ user: userInput, bot: response });

    // If bot doesn't understand the query, ask for user input to improve training data
    if (response === "I don't understand that. Can you rephrase?") {
      let userInputForTraining = prompt("How should the bot respond to this message?");
      if (userInputForTraining) {
        appendMessage('System', `Adding response to training data: ${userInputForTraining}`);
        // Replace the "I don't understand" fallback with the new user input
        const index = trainingData.conversationsamples.findIndex(sample => sample.user === userInput);
        if (index === -1) {
          // If no conversation sample exists, add a new one
          trainingData.conversationsamples.push({
            user: userInput,
            bot: userInputForTraining
          });
        } else {
          // Replace the bot response in the matched sample
          trainingData.conversationsamples[index].bot = userInputForTraining;
        }
        updateTrainingExport();
      }
    }
  }, 1000);
}

function exportConversations() {
  const exportContainer = document.getElementById('export-text');
  const filteredConversations = conversationHistory.filter(conv => conv.user && conv.bot);
  const exportData = filteredConversations.map(conv => 
    `{
  "user": "${conv.user}",
  "bot": "${conv.bot}"
}`).join(',\n'); // Adding a comma between objects

  exportContainer.textContent = `{
"conversationsamples": [
${exportData}
]
}`;
}



    // Event Listeners
    document.getElementById('send-btn').addEventListener('click', handleMessage);
    document.getElementById('user-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') handleMessage();
    });
    document.getElementById('refresh-btn').addEventListener('click', refreshTrainingData);
    document.getElementById('export-btn').addEventListener('click', exportConversations);

    // Load training data on start
    loadTrainingData();
  </script>
</body>
</html>
